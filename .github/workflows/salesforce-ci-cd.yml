# =============================================================================
# Salesforce CI/CD Pipeline
# =============================================================================
# This workflow automatically runs on every commit and Pull Request
# It will: 1) Summarize changes, 2) Validate against Salesforce org, 3) Deploy code

# Name of the workflow (appears in GitHub Actions tab)
name: Salesforce CI/CD Pipeline

# =============================================================================
# TRIGGER CONDITIONS
# =============================================================================
# Define when this workflow should run
on:
  # Run on every push (commit) to any branch
  push:
    # Only run when changes affect Salesforce code
    paths:
      - 'force-app/**'           # Any changes in force-app directory
      - 'sfdx-project.json'      # Changes to SFDX project configuration
      - 'manifest/**'            # Changes to deployment manifests
      - '.github/workflows/**'   # Changes to workflow files themselves

  # Run on Pull Request events
  pull_request:
    # Trigger on these PR actions
    types:
      - opened       # When PR is first created
      - synchronize  # When new commits are pushed to the PR
      - reopened     # When a closed PR is reopened
    # Only run when changes affect Salesforce code
    paths:
      - 'force-app/**'           # Any changes in force-app directory
      - 'sfdx-project.json'      # Changes to SFDX project configuration
      - 'manifest/**'            # Changes to deployment manifests

  # Optional: Allow manual workflow trigger from GitHub UI
  workflow_dispatch:
    # Add input parameters for manual runs
    inputs:
      deploy_to_production:
        description: 'Deploy to production?'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
# =============================================================================
# PERMISSIONS
# =============================================================================
# Grant permissions to GitHub Actions to interact with Pull Requests
# Without these, the workflow cannot post comments or update PR status
permissions:
  # Allow reading repository contents (code, files)
  contents: read

  # Allow writing to Pull Requests (post comments, update status)
  pull-requests: write

  # Allow writing to Issues (PRs are a type of issue in GitHub)
  issues: write

  # Allow reading checks and statuses
  checks: read
  
# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
# These variables are available to all jobs in the workflow
# You'll set the actual values in GitHub Settings > Secrets and Variables
env:
  # Salesforce API version to use (should match sfdx-project.json)
  SF_API_VERSION: '64.0'

  # Node.js version for running Salesforce CLI
  NODE_VERSION: '18'

  # Salesforce CLI version to install
  SFDX_CLI_VERSION: 'latest'

# =============================================================================
# JOBS - The actual work to be done
# =============================================================================
jobs:

  # ===========================================================================
  # JOB 1: SUMMARIZE CHANGES
  # ===========================================================================
  # This job analyzes what files changed in the Pull Request
  summarize-changes:
    # Job display name in GitHub UI
    name: 📝 Summarize Changes

    # Use Ubuntu Linux as the virtual machine
    runs-on: ubuntu-latest

    # Save outputs from this job so other jobs can use them
    outputs:
      has_apex: ${{ steps.check_changes.outputs.has_apex }}
      has_lwc: ${{ steps.check_changes.outputs.has_lwc }}
      has_metadata: ${{ steps.check_changes.outputs.has_metadata }}
      changed_files: ${{ steps.check_changes.outputs.changed_files }}

    # Steps are individual tasks within the job
    steps:
      # STEP 1: Get the code from the repository
      - name: 📥 Checkout Code
        # Uses a pre-built action from GitHub marketplace
        uses: actions/checkout@v4
        with:
          # Fetch full history to compare changes
          fetch-depth: 0

      # STEP 2: Analyze what files were changed
      - name: 🔍 Check Changed Files
        id: check_changes
        # Run shell commands to analyze changes
        run: |
          echo "=== Analyzing Changed Files ==="
          echo "Event: ${{ github.event_name }}"

          # Determine how to get changed files based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For Pull Requests: compare against base branch
            echo "Comparing PR branch against base branch..."
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }} HEAD)
          else
            # For push events: compare against previous commit
            echo "Comparing against previous commit..."
            if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
              # First commit in a new branch
              echo "First commit detected, getting all files in force-app/"
              CHANGED_FILES=$(git ls-files force-app/)
            else
              # Regular commit
              CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
            fi
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check if Apex classes changed (*.cls files)
          if echo "$CHANGED_FILES" | grep -q "\.cls$"; then
            echo "has_apex=true" >> $GITHUB_OUTPUT
            echo "✅ Apex classes changed"
          else
            echo "has_apex=false" >> $GITHUB_OUTPUT
            echo "⚪ No Apex changes"
          fi

          # Check if Lightning Web Components changed (lwc folder)
          if echo "$CHANGED_FILES" | grep -q "lwc/"; then
            echo "has_lwc=true" >> $GITHUB_OUTPUT
            echo "✅ Lightning Web Components changed"
          else
            echo "has_lwc=false" >> $GITHUB_OUTPUT
            echo "⚪ No LWC changes"
          fi

          # Check if any metadata changed (xml files)
          if echo "$CHANGED_FILES" | grep -q "\.xml$\|\.object-meta\.xml$"; then
            echo "has_metadata=true" >> $GITHUB_OUTPUT
            echo "✅ Metadata changed"
          else
            echo "has_metadata=false" >> $GITHUB_OUTPUT
            echo "⚪ No metadata changes"
          fi

          # Save changed files list (replace newlines with commas)
          echo "changed_files=$(echo $CHANGED_FILES | tr '\n' ',')" >> $GITHUB_OUTPUT

      # STEP 3: Create a comment on the PR with summary
      - name: 💬 Post Summary Comment
        # This action creates/updates a comment on the Pull Request
        # Only run this step if triggered by a pull_request event
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          # JavaScript code to create the comment
          script: |
            const hasApex = '${{ steps.check_changes.outputs.has_apex }}' === 'true';
            const hasLwc = '${{ steps.check_changes.outputs.has_lwc }}' === 'true';
            const hasMetadata = '${{ steps.check_changes.outputs.has_metadata }}' === 'true';

            // Build the comment message with emojis for visual appeal
            const comment = `## 📊 Salesforce Changes Summary

            **Components Changed:**
            - ${hasApex ? '✅' : '⚪'} Apex Classes
            - ${hasLwc ? '✅' : '⚪'} Lightning Web Components
            - ${hasMetadata ? '✅' : '⚪'} Metadata (Objects, Fields, etc.)

            **Next Steps:**
            - ✅ Step 1: Summary (This step)
            - ⏳ Step 2: Validation against Salesforce org
            - ⏳ Step 3: Deployment

            🤖 This comment is auto-generated by the CI/CD pipeline.`;

            // Post the comment to the PR
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  # ===========================================================================
  # JOB 2: VALIDATE AGAINST SALESFORCE ORG
  # ===========================================================================
  # This job checks if the code can be deployed without actually deploying
  validate-deployment:
    # Job display name
    name: ✅ Validate Deployment

    # This job needs the summary job to complete first
    needs: summarize-changes

    # Run on Ubuntu Linux
    runs-on: ubuntu-latest

    steps:
      # STEP 1: Get the code
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      # STEP 2: Set up Node.js (required for Salesforce CLI)
      - name: 🔧 Setup Node.js
        uses: actions/setup-node@v4
        with:
          # Use version from environment variable
          node-version: ${{ env.NODE_VERSION }}
          # Enable caching for npm to speed up installations
          cache: 'npm'
          cache-dependency-path: '**/package.json'

      # STEP 3: Cache Salesforce CLI
      - name: 💾 Cache Salesforce CLI
        id: cache-sf-cli
        uses: actions/cache@v3
        with:
          path: ~/.sf
          key: sf-cli-${{ runner.os }}-${{ env.SFDX_CLI_VERSION }}
          restore-keys: |
            sf-cli-${{ runner.os }}-

      # STEP 4: Install Salesforce CLI
      - name: 📦 Install Salesforce CLI
        # Only install if not cached
        if: steps.cache-sf-cli.outputs.cache-hit != 'true'
        run: |
          echo "=== Installing Salesforce CLI ==="
          # npm: Node Package Manager (installs software)
          # -g: install globally (available everywhere)
          # @salesforce/cli: the Salesforce CLI package
          npm install -g @salesforce/cli@${{ env.SFDX_CLI_VERSION }}
          echo "✅ Salesforce CLI installed successfully"

      # STEP 5: Verify Salesforce CLI
      - name: ✓ Verify Salesforce CLI
        run: |
          sf --version
          echo "✅ Salesforce CLI ready"

      # STEP 6: Authenticate to Salesforce using JWT
      - name: 🔐 Authenticate to Salesforce
        run: |
          echo "=== Authenticating to Salesforce ==="

          # Check if secrets are set (without revealing the values)
          if [ -z "${{ secrets.SF_JWT_KEY }}" ]; then
            echo "❌ ERROR: SF_JWT_KEY secret is not set!"
            echo "Please add SF_JWT_KEY in GitHub Settings > Secrets and Variables > Actions"
            exit 1
          fi

          if [ -z "${{ secrets.SF_CONSUMER_KEY }}" ]; then
            echo "❌ ERROR: SF_CONSUMER_KEY secret is not set!"
            exit 1
          fi

          if [ -z "${{ secrets.SF_USERNAME }}" ]; then
            echo "❌ ERROR: SF_USERNAME secret is not set!"
            exit 1
          fi

          if [ -z "${{ secrets.SF_INSTANCE_URL }}" ]; then
            echo "❌ ERROR: SF_INSTANCE_URL secret is not set!"
            exit 1
          fi

          echo "✅ All required secrets are set"

          # Create server.key file from the secret variable
          # This is your private key for JWT authentication
          # The printf command preserves newlines and special characters
          printf "%s" "${{ secrets.SF_JWT_KEY }}" > server.key

          # Check if the key file was created successfully
          if [ ! -s server.key ]; then
            echo "❌ ERROR: server.key file is empty!"
            echo "Check that SF_JWT_KEY contains the complete private key"
            exit 1
          fi

          echo "✅ JWT key file created successfully"

          # Display key file info (first and last line only, for debugging)
          echo "Key file first line: $(head -n 1 server.key)"
          echo "Key file last line: $(tail -n 1 server.key)"
          echo "Key file size: $(wc -c < server.key) bytes"

          # Authenticate using JWT (JSON Web Token) flow
          # This is a secure way to authenticate without password
          echo "Attempting JWT authentication..."
          sf org login jwt \
            --client-id "${{ secrets.SF_CONSUMER_KEY }}" \
            --jwt-key-file server.key \
            --username "${{ secrets.SF_USERNAME }}" \
            --instance-url "${{ secrets.SF_INSTANCE_URL }}" \
            --alias validation-org \
            --set-default

          # Remove the key file for security
          rm server.key

          echo "✅ Authentication successful"

      # STEP 7: Validate the deployment (check only, don't deploy)
      - name: 🔍 Validate Deployment
        id: validate
        run: |
          echo "=== Starting Validation ==="

          # Deploy with --dry-run flag to validate without deploying
          # --source-path: what to deploy
          # --test-level RunLocalTests: run all tests in your org
          # --target-org: which org to validate against
          # --wait: how long to wait for validation (in minutes)
          sf project deploy start \
            --source-dir force-app \
            --target-org validation-org \
            --dry-run \
            --wait 30 \
            --verbose

          echo "✅ Validation completed successfully"

      # STEP 8: Post validation results to PR
      - name: 💬 Post Validation Results
        # Only run on pull requests, and always run (even if validation fails)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.validate.outcome }}' === 'success';
            const comment = `## 🔍 Validation Results

            ${success ? '✅ **Validation Passed!**' : '❌ **Validation Failed!**'}

            ${success
              ? 'Your changes can be safely deployed to Salesforce.'
              : 'Please check the logs for errors and fix them before merging.'}

            **Steps Completed:**
            - ✅ Step 1: Summary
            - ${success ? '✅' : '❌'} Step 2: Validation
            - ⏳ Step 3: Deployment (pending)

            [View Full Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  # ===========================================================================
  # JOB 3: DEPLOY TO SALESFORCE
  # ===========================================================================
  # This job actually deploys the code to production/staging
  deploy-to-salesforce:
    # Job display name
    name: 🚀 Deploy to Salesforce

    # Only run this job if:
    # 1. Validation passed AND
    # 2. One of these conditions is met:
    #    - Push to main/master branch (after PR merge)
    #    - Manual workflow trigger with deploy flag
    needs: validate-deployment

    # Smart deployment logic:
    # - Deploy on push to main/master (after PR is merged)
    # - Deploy on manual workflow trigger
    # - Skip deployment on PR validation (just validate, don't deploy)
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_to_production == 'true')

    runs-on: ubuntu-latest

    steps:
      # STEP 1: Get the code
      - name: 📥 Checkout Code
        uses: actions/checkout@v4
        with:
          # Fetch more history to compare changes
          fetch-depth: 0

      # STEP 2: Check if there are Salesforce changes to deploy
      - name: 🔍 Check for Salesforce Changes
        id: check_deploy
        run: |
          echo "=== Checking for Salesforce changes to deploy ==="

          # Check if force-app directory exists
          if [ ! -d "force-app" ]; then
            echo "❌ force-app directory not found!"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Count files in force-app
          FILE_COUNT=$(find force-app -type f | wc -l | tr -d ' ')
          echo "📊 Total files in force-app: $FILE_COUNT"

          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "⚠️  No files found in force-app/"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "✅ Found $FILE_COUNT files to deploy"
            echo "has_changes=true" >> $GITHUB_OUTPUT

            # Show what types of components will be deployed
            echo ""
            echo "📦 Components to deploy:"

            # Count Apex Classes
            if [ -d "force-app/main/default/classes" ]; then
              APEX_COUNT=$(find force-app/main/default/classes -name "*.cls" 2>/dev/null | wc -l | tr -d ' ')
              echo "  ✅ Apex Classes: $APEX_COUNT"
            fi

            # Count Apex Triggers
            if [ -d "force-app/main/default/triggers" ]; then
              TRIGGER_COUNT=$(find force-app/main/default/triggers -name "*.trigger" 2>/dev/null | wc -l | tr -d ' ')
              echo "  ✅ Apex Triggers: $TRIGGER_COUNT"
            fi

            # Count Lightning Web Components
            if [ -d "force-app/main/default/lwc" ]; then
              LWC_COUNT=$(find force-app/main/default/lwc -type d -mindepth 1 -maxdepth 1 2>/dev/null | wc -l | tr -d ' ')
              echo "  ✅ Lightning Web Components: $LWC_COUNT"
            fi

            # Count Aura Components
            if [ -d "force-app/main/default/aura" ]; then
              AURA_COUNT=$(find force-app/main/default/aura -type d -mindepth 1 -maxdepth 1 2>/dev/null | wc -l | tr -d ' ')
              echo "  ✅ Aura Components: $AURA_COUNT"
            fi

            # Count Custom Objects
            if [ -d "force-app/main/default/objects" ]; then
              OBJECT_COUNT=$(find force-app/main/default/objects -type d -mindepth 1 -maxdepth 1 2>/dev/null | wc -l | tr -d ' ')
              echo "  ✅ Custom Objects: $OBJECT_COUNT"
            fi
          fi

      # STEP 3: Setup Node.js
      - name: 🔧 Setup Node.js
        # Only run if there are changes to deploy
        if: steps.check_deploy.outputs.has_changes == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      # STEP 4: Install Salesforce CLI
      - name: 📦 Install Salesforce CLI
        # Only run if there are changes to deploy
        if: steps.check_deploy.outputs.has_changes == 'true'
        run: |
          npm install -g @salesforce/cli@${{ env.SFDX_CLI_VERSION }}
          sf --version

      # STEP 5: Authenticate to Salesforce
      - name: 🔐 Authenticate to Salesforce
        # Only run if there are changes to deploy
        if: steps.check_deploy.outputs.has_changes == 'true'
        run: |
          echo "=== Authenticating to Production Org ==="

          # Determine which credentials to use (production or default)
          CONSUMER_KEY="${{ secrets.SF_PROD_CONSUMER_KEY }}"
          USERNAME="${{ secrets.SF_PROD_USERNAME }}"
          INSTANCE_URL="${{ secrets.SF_PROD_INSTANCE_URL }}"

          # Fall back to default credentials if production credentials are not set
          if [ -z "$CONSUMER_KEY" ]; then
            echo "⚠️  SF_PROD_CONSUMER_KEY not set, using SF_CONSUMER_KEY"
            CONSUMER_KEY="${{ secrets.SF_CONSUMER_KEY }}"
          fi

          if [ -z "$USERNAME" ]; then
            echo "⚠️  SF_PROD_USERNAME not set, using SF_USERNAME"
            USERNAME="${{ secrets.SF_USERNAME }}"
          fi

          if [ -z "$INSTANCE_URL" ]; then
            echo "⚠️  SF_PROD_INSTANCE_URL not set, using SF_INSTANCE_URL"
            INSTANCE_URL="${{ secrets.SF_INSTANCE_URL }}"
          fi

          # Validate all required credentials are set
          if [ -z "${{ secrets.SF_JWT_KEY }}" ]; then
            echo "❌ ERROR: SF_JWT_KEY secret is not set!"
            exit 1
          fi

          if [ -z "$CONSUMER_KEY" ]; then
            echo "❌ ERROR: No consumer key found!"
            exit 1
          fi

          if [ -z "$USERNAME" ]; then
            echo "❌ ERROR: No username found!"
            exit 1
          fi

          if [ -z "$INSTANCE_URL" ]; then
            echo "❌ ERROR: No instance URL found!"
            exit 1
          fi

          echo "✅ Using credentials for: $USERNAME"
          echo "✅ Instance URL: $INSTANCE_URL"

          # Create server.key file from the secret variable
          printf "%s" "${{ secrets.SF_JWT_KEY }}" > server.key

          # Check if the key file was created successfully
          if [ ! -s server.key ]; then
            echo "❌ ERROR: server.key file is empty!"
            exit 1
          fi

          echo "✅ JWT key file created successfully"

          # Authenticate using JWT
          echo "Attempting JWT authentication..."
          sf org login jwt \
            --client-id "$CONSUMER_KEY" \
            --jwt-key-file server.key \
            --username "$USERNAME" \
            --instance-url "$INSTANCE_URL" \
            --alias production-org \
            --set-default

          rm server.key
          echo "✅ Authenticated to production org"

      # STEP 6: Deploy to Salesforce (actual deployment)
      - name: 🚀 Deploy to Salesforce
        id: deploy
        # Only run if there are changes to deploy
        if: steps.check_deploy.outputs.has_changes == 'true'
        run: |
          echo "=== Starting Deployment ==="
          echo "🎯 Branch: ${{ github.ref }}"
          echo "🎯 Event: ${{ github.event_name }}"
          echo "🎯 Target Org: production-org"

          # Deploy without --dry-run flag (this is real!)
          # Using --verbose for detailed output
          echo ""
          echo "📤 Deploying to Salesforce..."
          sf project deploy start \
            --source-path force-app \
            --test-level RunLocalTests \
            --target-org production-org \
            --wait 30 \
            --verbose

          echo ""
          echo "✅ Deployment completed successfully!"

          # Show deployment summary
          echo ""
          echo "📊 Deployment Summary:"
          sf project deploy report --target-org production-org || true

      # STEP 7: Skip deployment notification
      - name: ⏭️ No Changes to Deploy
        # Only run if there are NO changes
        if: steps.check_deploy.outputs.has_changes != 'true'
        run: |
          echo "ℹ️  No Salesforce changes detected in force-app/"
          echo "ℹ️  Skipping deployment step"
          echo ""
          echo "This is normal if:"
          echo "  - You only changed documentation files"
          echo "  - You only changed CI/CD configuration"
          echo "  - No force-app/ files were modified"

      # STEP 8: Post deployment results
      - name: 💬 Post Deployment Results
        # Only run on pull requests, and always run (even if deployment fails)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.deploy.outcome }}' === 'success';
            const comment = `## 🚀 Deployment Results

            ${success ? '✅ **Deployment Successful!**' : '❌ **Deployment Failed!**'}

            ${success
              ? 'Your changes are now live in Salesforce! 🎉'
              : 'Deployment failed. Please check the logs and contact the admin.'}

            **All Steps Completed:**
            - ✅ Step 1: Summary
            - ✅ Step 2: Validation
            - ${success ? '✅' : '❌'} Step 3: Deployment

            **Deployment Time:** ${{ github.event.repository.updated_at }}

            [View Full Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      # STEP 7: Send notification on failure (optional)
      - name: 📧 Notify on Failure
        if: failure()
        run: |
          echo "❌ Deployment failed!"
          echo "Please check the GitHub Actions logs for details"
          # You can add email notification or Slack webhook here
