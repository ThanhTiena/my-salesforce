# =============================================================================
# Salesforce CI/CD Pipeline
# =============================================================================
# This workflow automatically runs on every commit and Pull Request
# It will: 1) Summarize changes, 2) Validate against Salesforce org, 3) Deploy code

# Name of the workflow (appears in GitHub Actions tab)
name: Salesforce CI/CD Pipeline

# =============================================================================
# TRIGGER CONDITIONS
# =============================================================================
# Define when this workflow should run
on:
  # Run on every push (commit) to any branch
  push:
    # Only run when changes affect Salesforce code
    paths:
      - 'force-app/**'           # Any changes in force-app directory
      - 'sfdx-project.json'      # Changes to SFDX project configuration
      - 'manifest/**'            # Changes to deployment manifests
      - '.github/workflows/**'   # Changes to workflow files themselves

  # Run on Pull Request events
  pull_request:
    # Trigger on these PR actions
    types:
      - opened       # When PR is first created
      - synchronize  # When new commits are pushed to the PR
      - reopened     # When a closed PR is reopened
    # Only run when changes affect Salesforce code
    paths:
      - 'force-app/**'           # Any changes in force-app directory
      - 'sfdx-project.json'      # Changes to SFDX project configuration
      - 'manifest/**'            # Changes to deployment manifests

  # Optional: Allow manual workflow trigger from GitHub UI
  workflow_dispatch:
    # Add input parameters for manual runs
    inputs:
      deploy_to_production:
        description: 'Deploy to production?'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
# =============================================================================
# PERMISSIONS
# =============================================================================
# Grant permissions to GitHub Actions to interact with Pull Requests
# Without these, the workflow cannot post comments or update PR status
permissions:
  # Allow reading repository contents (code, files)
  contents: read

  # Allow writing to Pull Requests (post comments, update status)
  pull-requests: write

  # Allow writing to Issues (PRs are a type of issue in GitHub)
  issues: write

  # Allow reading checks and statuses
  checks: read
  
# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
# These variables are available to all jobs in the workflow
# You'll set the actual values in GitHub Settings > Secrets and Variables
env:
  # Salesforce API version to use (should match sfdx-project.json)
  SF_API_VERSION: '64.0'

  # Node.js version for running Salesforce CLI
  NODE_VERSION: '18'

  # Salesforce CLI version to install
  SFDX_CLI_VERSION: 'latest'

# =============================================================================
# JOBS - The actual work to be done
# =============================================================================
jobs:

  # ===========================================================================
  # JOB 1: SUMMARIZE CHANGES
  # ===========================================================================
  # This job analyzes what files changed in the Pull Request
  summarize-changes:
    # Job display name in GitHub UI
    name: üìù Summarize Changes

    # Use Ubuntu Linux as the virtual machine
    runs-on: ubuntu-latest

    # Save outputs from this job so other jobs can use them
    outputs:
      has_apex: ${{ steps.check_changes.outputs.has_apex }}
      has_lwc: ${{ steps.check_changes.outputs.has_lwc }}
      has_metadata: ${{ steps.check_changes.outputs.has_metadata }}
      changed_files: ${{ steps.check_changes.outputs.changed_files }}

    # Steps are individual tasks within the job
    steps:
      # STEP 1: Get the code from the repository
      - name: üì• Checkout Code
        # Uses a pre-built action from GitHub marketplace
        uses: actions/checkout@v4
        with:
          # Fetch full history to compare changes
          fetch-depth: 0

      # STEP 2: Analyze what files were changed
      - name: üîç Check Changed Files
        id: check_changes
        # Run shell commands to analyze changes
        run: |
          echo "=== Analyzing Changed Files ==="
          echo "Event: ${{ github.event_name }}"

          # Determine how to get changed files based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For Pull Requests: compare against base branch
            echo "Comparing PR branch against base branch..."
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }} HEAD)
          else
            # For push events: compare against previous commit
            echo "Comparing against previous commit..."
            if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
              # First commit in a new branch
              echo "First commit detected, getting all files in force-app/"
              CHANGED_FILES=$(git ls-files force-app/)
            else
              # Regular commit
              CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
            fi
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check if Apex classes changed (*.cls files)
          if echo "$CHANGED_FILES" | grep -q "\.cls$"; then
            echo "has_apex=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Apex classes changed"
          else
            echo "has_apex=false" >> $GITHUB_OUTPUT
            echo "‚ö™ No Apex changes"
          fi

          # Check if Lightning Web Components changed (lwc folder)
          if echo "$CHANGED_FILES" | grep -q "lwc/"; then
            echo "has_lwc=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Lightning Web Components changed"
          else
            echo "has_lwc=false" >> $GITHUB_OUTPUT
            echo "‚ö™ No LWC changes"
          fi

          # Check if any metadata changed (xml files)
          if echo "$CHANGED_FILES" | grep -q "\.xml$\|\.object-meta\.xml$"; then
            echo "has_metadata=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Metadata changed"
          else
            echo "has_metadata=false" >> $GITHUB_OUTPUT
            echo "‚ö™ No metadata changes"
          fi

          # Save changed files list (replace newlines with commas)
          echo "changed_files=$(echo $CHANGED_FILES | tr '\n' ',')" >> $GITHUB_OUTPUT

      # STEP 3: Create a comment on the PR with summary
      - name: üí¨ Post Summary Comment
        # This action creates/updates a comment on the Pull Request
        # Only run this step if triggered by a pull_request event
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          # JavaScript code to create the comment
          script: |
            const hasApex = '${{ steps.check_changes.outputs.has_apex }}' === 'true';
            const hasLwc = '${{ steps.check_changes.outputs.has_lwc }}' === 'true';
            const hasMetadata = '${{ steps.check_changes.outputs.has_metadata }}' === 'true';

            // Build the comment message with emojis for visual appeal
            const comment = `## üìä Salesforce Changes Summary

            **Components Changed:**
            - ${hasApex ? '‚úÖ' : '‚ö™'} Apex Classes
            - ${hasLwc ? '‚úÖ' : '‚ö™'} Lightning Web Components
            - ${hasMetadata ? '‚úÖ' : '‚ö™'} Metadata (Objects, Fields, etc.)

            **Next Steps:**
            - ‚úÖ Step 1: Summary (This step)
            - ‚è≥ Step 2: Validation against Salesforce org
            - ‚è≥ Step 3: Deployment

            ü§ñ This comment is auto-generated by the CI/CD pipeline.`;

            // Post the comment to the PR
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  # ===========================================================================
  # JOB 2: VALIDATE AGAINST SALESFORCE ORG
  # ===========================================================================
  # This job checks if the code can be deployed without actually deploying
  validate-deployment:
    # Job display name
    name: ‚úÖ Validate Deployment

    # This job needs the summary job to complete first
    needs: summarize-changes

    # Run on Ubuntu Linux
    runs-on: ubuntu-latest

    steps:
      # STEP 1: Get the code
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # STEP 2: Set up Node.js (required for Salesforce CLI)
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          # Use version from environment variable
          node-version: ${{ env.NODE_VERSION }}

      # STEP 3: Install Salesforce CLI
      - name: üì¶ Install Salesforce CLI
        run: |
          echo "=== Installing Salesforce CLI ==="
          # npm: Node Package Manager (installs software)
          # -g: install globally (available everywhere)
          # @salesforce/cli: the Salesforce CLI package
          npm install -g @salesforce/cli@${{ env.SFDX_CLI_VERSION }}

          # Verify installation
          sf --version
          echo "‚úÖ Salesforce CLI installed successfully"

      # STEP 4: Authenticate to Salesforce using JWT
      - name: üîê Authenticate to Salesforce
        run: |
          echo "=== Authenticating to Salesforce ==="

          # Check if secrets are set (without revealing the values)
          if [ -z "${{ secrets.SF_JWT_KEY }}" ]; then
            echo "‚ùå ERROR: SF_JWT_KEY secret is not set!"
            echo "Please add SF_JWT_KEY in GitHub Settings > Secrets and Variables > Actions"
            exit 1
          fi

          if [ -z "${{ secrets.SF_CONSUMER_KEY }}" ]; then
            echo "‚ùå ERROR: SF_CONSUMER_KEY secret is not set!"
            exit 1
          fi

          if [ -z "${{ secrets.SF_USERNAME }}" ]; then
            echo "‚ùå ERROR: SF_USERNAME secret is not set!"
            exit 1
          fi

          if [ -z "${{ secrets.SF_INSTANCE_URL }}" ]; then
            echo "‚ùå ERROR: SF_INSTANCE_URL secret is not set!"
            exit 1
          fi

          echo "‚úÖ All required secrets are set"

          # Create server.key file from the secret variable
          # This is your private key for JWT authentication
          # The printf command preserves newlines and special characters
          printf "%s" "${{ secrets.SF_JWT_KEY }}" > server.key

          # Check if the key file was created successfully
          if [ ! -s server.key ]; then
            echo "‚ùå ERROR: server.key file is empty!"
            echo "Check that SF_JWT_KEY contains the complete private key"
            exit 1
          fi

          echo "‚úÖ JWT key file created successfully"

          # Display key file info (first and last line only, for debugging)
          echo "Key file first line: $(head -n 1 server.key)"
          echo "Key file last line: $(tail -n 1 server.key)"
          echo "Key file size: $(wc -c < server.key) bytes"

          # Authenticate using JWT (JSON Web Token) flow
          # This is a secure way to authenticate without password
          echo "Attempting JWT authentication..."
          sf org login jwt \
            --client-id "${{ secrets.SF_CONSUMER_KEY }}" \
            --jwt-key-file server.key \
            --username "${{ secrets.SF_USERNAME }}" \
            --instance-url "${{ secrets.SF_INSTANCE_URL }}" \
            --alias validation-org \
            --set-default

          # Remove the key file for security
          rm server.key

          echo "‚úÖ Authentication successful"

      # STEP 5: Validate the deployment (check only, don't deploy)
      - name: üîç Validate Deployment
        id: validate
        run: |
          echo "=== Starting Validation ==="

          # Deploy with --dry-run flag to validate without deploying
          # --source-path: what to deploy
          # --test-level RunLocalTests: run all tests in your org
          # --target-org: which org to validate against
          # --wait: how long to wait for validation (in minutes)
          sf project deploy start \
            --source-path force-app \
            --test-level RunLocalTests \
            --target-org validation-org \
            --dry-run \
            --wait 30 \
            --verbose

          echo "‚úÖ Validation completed successfully"

      # STEP 6: Post validation results to PR
      - name: üí¨ Post Validation Results
        # Only run on pull requests, and always run (even if validation fails)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.validate.outcome }}' === 'success';
            const comment = `## üîç Validation Results

            ${success ? '‚úÖ **Validation Passed!**' : '‚ùå **Validation Failed!**'}

            ${success
              ? 'Your changes can be safely deployed to Salesforce.'
              : 'Please check the logs for errors and fix them before merging.'}

            **Steps Completed:**
            - ‚úÖ Step 1: Summary
            - ${success ? '‚úÖ' : '‚ùå'} Step 2: Validation
            - ‚è≥ Step 3: Deployment (pending)

            [View Full Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  # ===========================================================================
  # JOB 3: DEPLOY TO SALESFORCE
  # ===========================================================================
  # This job actually deploys the code after PR is merged
  deploy-to-salesforce:
    # Job display name
    name: üöÄ Deploy to Salesforce

    # Only run this job if:
    # 1. Validation passed
    # 2. PR was merged (not just closed)
    needs: validate-deployment

    # Only run on the main branch (after PR is merged)
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'

    runs-on: ubuntu-latest

    steps:
      # STEP 1: Get the code
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # STEP 2: Setup Node.js
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      # STEP 3: Install Salesforce CLI
      - name: üì¶ Install Salesforce CLI
        run: |
          npm install -g @salesforce/cli@${{ env.SFDX_CLI_VERSION }}
          sf --version

      # STEP 4: Authenticate to Salesforce
      - name: üîê Authenticate to Salesforce
        run: |
          echo "=== Authenticating to Production Org ==="

          # Determine which credentials to use (production or default)
          CONSUMER_KEY="${{ secrets.SF_PROD_CONSUMER_KEY }}"
          USERNAME="${{ secrets.SF_PROD_USERNAME }}"
          INSTANCE_URL="${{ secrets.SF_PROD_INSTANCE_URL }}"

          # Fall back to default credentials if production credentials are not set
          if [ -z "$CONSUMER_KEY" ]; then
            echo "‚ö†Ô∏è  SF_PROD_CONSUMER_KEY not set, using SF_CONSUMER_KEY"
            CONSUMER_KEY="${{ secrets.SF_CONSUMER_KEY }}"
          fi

          if [ -z "$USERNAME" ]; then
            echo "‚ö†Ô∏è  SF_PROD_USERNAME not set, using SF_USERNAME"
            USERNAME="${{ secrets.SF_USERNAME }}"
          fi

          if [ -z "$INSTANCE_URL" ]; then
            echo "‚ö†Ô∏è  SF_PROD_INSTANCE_URL not set, using SF_INSTANCE_URL"
            INSTANCE_URL="${{ secrets.SF_INSTANCE_URL }}"
          fi

          # Validate all required credentials are set
          if [ -z "${{ secrets.SF_JWT_KEY }}" ]; then
            echo "‚ùå ERROR: SF_JWT_KEY secret is not set!"
            exit 1
          fi

          if [ -z "$CONSUMER_KEY" ]; then
            echo "‚ùå ERROR: No consumer key found!"
            exit 1
          fi

          if [ -z "$USERNAME" ]; then
            echo "‚ùå ERROR: No username found!"
            exit 1
          fi

          if [ -z "$INSTANCE_URL" ]; then
            echo "‚ùå ERROR: No instance URL found!"
            exit 1
          fi

          echo "‚úÖ Using credentials for: $USERNAME"
          echo "‚úÖ Instance URL: $INSTANCE_URL"

          # Create server.key file from the secret variable
          printf "%s" "${{ secrets.SF_JWT_KEY }}" > server.key

          # Check if the key file was created successfully
          if [ ! -s server.key ]; then
            echo "‚ùå ERROR: server.key file is empty!"
            exit 1
          fi

          echo "‚úÖ JWT key file created successfully"

          # Authenticate using JWT
          echo "Attempting JWT authentication..."
          sf org login jwt \
            --client-id "$CONSUMER_KEY" \
            --jwt-key-file server.key \
            --username "$USERNAME" \
            --instance-url "$INSTANCE_URL" \
            --alias production-org \
            --set-default

          rm server.key
          echo "‚úÖ Authenticated to production org"

      # STEP 5: Deploy to Salesforce (actual deployment)
      - name: üöÄ Deploy to Salesforce
        id: deploy
        run: |
          echo "=== Starting Deployment ==="

          # Deploy without --dry-run flag (this is real!)
          sf project deploy start \
            --source-path force-app \
            --test-level RunLocalTests \
            --target-org production-org \
            --wait 30 \
            --verbose

          echo "‚úÖ Deployment completed successfully!"

      # STEP 6: Post deployment results
      - name: üí¨ Post Deployment Results
        # Only run on pull requests, and always run (even if deployment fails)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const success = '${{ steps.deploy.outcome }}' === 'success';
            const comment = `## üöÄ Deployment Results

            ${success ? '‚úÖ **Deployment Successful!**' : '‚ùå **Deployment Failed!**'}

            ${success
              ? 'Your changes are now live in Salesforce! üéâ'
              : 'Deployment failed. Please check the logs and contact the admin.'}

            **All Steps Completed:**
            - ‚úÖ Step 1: Summary
            - ‚úÖ Step 2: Validation
            - ${success ? '‚úÖ' : '‚ùå'} Step 3: Deployment

            **Deployment Time:** ${{ github.event.repository.updated_at }}

            [View Full Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      # STEP 7: Send notification on failure (optional)
      - name: üìß Notify on Failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          echo "Please check the GitHub Actions logs for details"
          # You can add email notification or Slack webhook here
